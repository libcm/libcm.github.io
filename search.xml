<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[视频提取音频和音频裁剪]]></title>
    <url>%2F2019%2F08%2F12%2F%E8%A7%86%E9%A2%91%E6%8F%90%E5%8F%96%E9%9F%B3%E9%A2%91%E5%92%8C%E9%9F%B3%E9%A2%91%E8%A3%81%E5%89%AA%2F</url>
    <content type="text"><![CDATA[最近项目中需要从视频中提取音频，并需要根据音频时间间隔进行裁剪，所以在此记录下实现过程。 音频提取音频提取原理是通过创建只包含原始文件的音频音轨并使用 AVAssetExportSession导出组合文件的AVMutableComposition 来完成音频提取。 123456789101112131415161718192021222324252627282930/*输出路径self.cachePath: 获取缓存路径*/NSString *outPath = [self.cachePath stringByAppendingPathComponent: [NSString stringWithFormat:@"%@.m4a", name]];// 创建组合文件AVMutableComposition *composition = [[AVMutableComposition alloc] init];NSURL *url = [NSURL fileURLWithPath:path];AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil];AVAssetTrack *track = [asset tracksWithMediaType:AVMediaTypeAudio].firstObject;AVMutableCompositionTrack *comTrack = [composition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];NSError *error;[comTrack insertTimeRange:track.timeRange ofTrack:track atTime:kCMTimeZero error:&amp;error];if (error) &#123; NSLog(@"创建失败");&#125;// 创建只包含原始文件的音频音轨AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:composition presetName:AVAssetExportPresetPassthrough];// 导出文件类型.m4a格式session.outputFileType = AVFileTypeAppleM4A;session.outputURL = [NSURL fileURLWithPath:outPath];// 音频导出[session exportAsynchronouslyWithCompletionHandler:^&#123; AVAssetExportSessionStatus status = session.status; if(AVAssetExportSessionStatusCompleted == status) &#123; NSLog(@"音频导出成功"); &#125; else &#123; NSLog(@"音频导出失败"); &#125;&#125;]; 音频裁剪1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*根据时间间隔裁剪音频path: 音频路径time: 时间间隔*/- (void)cutAudioWithPath:(NSString *)path intervalTime:(NSInteger)time &#123; // 获取音频时长 NSURL *url = [NSURL fileURLWithPath:path]; AVURLAsset*audioAsset = [AVURLAsset URLAssetWithURL:url options:nil]; CMTime totalDuration = audioAsset.duration; CGFloat audioSeconds = CMTimeGetSeconds(totalDuration); if (audioSeconds &gt; time) &#123; NSInteger number = ceil(audioSeconds / time); for (NSInteger idx = 0; idx &lt; number; idx ++) &#123; NSInteger t = idx * time; CMTime startTime = CMTimeMake(t, 1);; CMTime endTime; if (t &gt; audioSeconds) &#123; endTime = CMTimeMake(audioSeconds, 1); &#125; else &#123; endTime = CMTimeMake(time, 1); &#125; NSString *fileName = [NSString stringWithFormat:@"%zi.m4a", t]; NSString *outPutPath = [[self composeDir] stringByAppendingPathComponent:fileName]; NSURL *audioFileOutput = [NSURL fileURLWithPath:outPutPath]; [[NSFileManager defaultManager] removeItemAtURL:audioFileOutput error:NULL]; AVAsset *asset = [AVAsset assetWithURL:url]; AVAssetExportSession *exportSession = [AVAssetExportSession exportSessionWithAsset:asset presetName:AVAssetExportPresetAppleM4A]; CMTimeRange exportTimeRange = CMTimeRangeFromTimeToTime(startTime, endTime); exportSession.outputURL = audioFileOutput; exportSession.outputFileType = AVFileTypeAppleM4A; exportSession.timeRange = exportTimeRange; [exportSession exportAsynchronouslyWithCompletionHandler:^&#123; if (AVAssetExportSessionStatusCompleted == exportSession.status) &#123; NSLog(@"导出完成: %@", outPutPath); &#125; else if (AVAssetExportSessionStatusFailed == exportSession.status) &#123; NSLog(@"导出失败: %@", exportSession.error.localizedDescription); &#125; &#125;]; &#125; &#125; else &#123; NSLog(@"音频时长小于裁剪时间间隔"); &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向学习(一)-环境搭建]]></title>
    <url>%2F2019%2F08%2F11%2FiOS%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前提 越狱手机 如果没有越狱后面的操作无法实现，如何越狱，这里我们就不讲了，网上教程很多。 配置SSHSSH是Secure Shell简称， 是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。 配置SSH是我们后续工作的基础，我们可以通过SSH实现PC端访问iPhone手机。 安装所需APP卸载OpenSSH与OpenSSLiOS 10以后越狱自带SSH,但是无法连接iPhone或报错,所以需要首先卸载OpenSSH与OpenSSL。在Cydia中搜索OpenSSH与OpenSSL,然后卸载。 添加源自带源没有Dropbear，所以需要添加新源，这里我提供一个源: http://apt.abcydia.com,也可以自己搜索其他源。 安装Dropbear搜索Dropbear并安装。 安装MTerminal搜索MTerminal并安装。 连接iPhoneWIFI连接前提 PC与iPhone在同一局域网 打开MTerminal，输入以下命令 1su 输入root密码，默认为alpine,然后执行以下命令，查看dropbear进程是否执行 1ps aux|grep dropbear 如果没有dropbear进程，执行以下命令 1/usr/local/bin/dropbear -F -R -p 22 然后获取iPhone所在网络下的ip地址,PC终端执行以下命令 12// 172.20.122.108 iPhone ip地址ssh root@172.20.122.108 如果有以下提示 The authenticity of host &apos;192.168.1.105 (192.168.1.105)&apos; can&apos;t be established. ECDSA key fingerprint is SHA256:ANF7Cvc1yM/ZdaHyz9V1EHjG115cylIcHWyOzCL+kzs. Are you sure you want to continue connecting (yes/no)? 输入yes即可,然后输入root密码，默认密码alpine USB连接有时候网络不稳定的时候，使用WIFI连接响应可能会很慢，所以这里讲下比WIFI连接响应更快的USB连接。 安装usbmuxd1brew install usbmuxd 安装成功后,执行以下命令连接iPhone 12// 把iPhone的默认端口22映射到PC 2222端口上面iproxy 2222 22 执行完后，会一直显示waiting for connection，此时不要慌，再打开一个终端窗口,执行以下命令 123ssh -p 2222 root@localhost// 或ssh -p 2222 root@127.0.0.1 如果连接失败，请查看数据线是否连接正常;连接成功后就可以尽情访问iPhone里面数据了。 修改SSH密码ROOT密码1.首先使用root权限连接iPhone 1ssh root@xxx.xxx.xxx.xxx 2.执行下面命令，修改密码 1passwd 3.按提示输入两次新密码即可。4.exit命令退出连接。 mobile密码1.首先使用mobile权限连接iPhone 1ssh mobile@xxx.xxx.xxx.xxx 2.执行下面命令，修改密码 1passwd 3.按提示输入两次新密码即可。4.exit命令退出连接。 免密登录首先查看.ssh目录下是否存在id_rsa和id_rsa.pub，如果已存在，无需再次生成。 生成RSA公私钥终端执行以下命令 1ssh-keygen 查看.ssh目录下是否生成了id_rsa和id_rsa.pub文件。 推送公钥到iPhone连接iPhone，执行以下命令 12// 2222 iPhone的默认端口22映射PC端的端口号ssh-copy-id root@localhost -p 2222 输入密码，如果已修改，输入修改后的密码,未修改输入默认密码alpine。 接下来再次登录就会发线不用输入密码了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2F2019%2F05%2F07%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[博客搭建Hexo安装安装前提 Node.js Git 如果已经安装以上两项，可以直接安装hexo 1$ npm install -g hexo-cli 初始化Hexo 1234$ cd &lt;存放博客的路径&gt;$ hexo init &lt;博客名&gt;$ cd &lt;博客名&gt;$ npm install 创建完成,目录结构如下: . ├── _config.yml // 配置文件 ├── package.json // 应用程序的信息 ├── scaffolds // 模版 文件夹 ├── source // 资源文件夹 | ├── _drafts | └── _posts // 文章 └── themes // 主题 启动服务，查看效果 1$ hexo server // 或 hexo s 浏览器访问:http://localhost:4000/ Github关联创建仓库，命名规则 &lt;账户名&gt;.github.io 修改_config.yml配置文件，末尾修改为以下内容(注意:“:”后面有一个空格) deploy: type: git repository: https://github.com/xxx/xxx.github.io.git // 刚才创建仓库git链接 branch: master 推送到github仓库 12$ hexo g // 生成html静态文件$ hexo d // push到github 然后浏览器访问 https://&lt;账户名&gt;.github.io，即可查看博客 绑定域名购买域名:阿里云万网、腾讯云等 域名解析照下图添加即可 打开博客仓库]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS 10.14.x安装旧版iTunes]]></title>
    <url>%2F2019%2F04%2F17%2FMacOS%2010.14.x%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88iTunes%2F</url>
    <content type="text"><![CDATA[iTunes12.6.x下载地址iTunes12.6.x 关闭sip系统完整性保护打开Mac终端输入命令查看sip状态 1csrutil status 如果是disabled直接跳过关闭sip步骤,如果是enabled执行下一步 重启电脑,按住cmmand+r直到显示苹果图标时松开，进入修复模式。 点击顶部导航栏实用工具,选择终端。 终端中输入命令关闭sip 1csrutil disable 重启电脑. 执行脚本安装旧版iTunes1.打开LaunchPad找到脚本编辑器，粘贴下面脚本代码,点击运行按照提示选择12.6.x版本iTunes安装即可. 1234567891011121314151617181920212223242526272829set question to display dialog "Delete iTtunes?" buttons &#123;"Yes", "No"&#125; default button 1set answer to button returned of questionif answer is equal to "Yes" then do shell script "rm -rf /Applications/iTunes.app" with administrator privileges display dialog "iTunes was deleted" buttons &#123;"Ok"&#125; set theDMG to choose file with prompt "Please select iTunes 12.6 dmg file:" of type &#123;"dmg"&#125; do shell script "hdiutil mount " &amp; quoted form of POSIX path of theDMG do shell script "pkgutil --expand /Volumes/iTunes/Install\\ iTunes.pkg ~/tmp" do shell script "sed -i '' 's/18A1/14F2511/g' ~/tmp/Distribution" do shell script "sed -i '' 's/gt/lt/g' ~/tmp/Distribution" do shell script "pkgutil --flatten ~/tmp ~/Desktop/iTunes.pkg" do shell script "hdiutil unmount /Volumes/iTunes/" do shell script "rm -rf ~/tmp"end ifif answer is equal to "No" then display dialog "iTunes was not deleted" buttons &#123;"Ok"&#125; returnend if set question to display dialog "Install iTtunes?" buttons &#123;"Yes", "No"&#125; default button 1set answer to button returned of questionif answer is equal to "Yes" then do shell script "open ~/Desktop/iTunes.pkg" returnend ifif answer is equal to "No" then display dialog "Modified iTunes.pkg saved on desktop" buttons &#123;"Ok"&#125; returnend if 运行时如果提示 iTunes Library.itl错误,终端运行命令：1sudo rm ~/Music/iTunes/iTunes\ Library.itl 安装完成重启电脑进入修复模式，终端中输入命令开启sip1csrutil enable MacOS 10.14.4无法打开问题解决点击iTunes提示“应用程序“iTunes”的这个版本不能与此版本的 macOS 配合使用。您使用的是“iTunes”12.6.x” 解决办法：在运行上面的脚本之前，复制「访达」—「应用程序」—「iTunes.app」—「显示包内容」中的version.plist和Info.plist两个文件并保存备用。安装好旧版本的itunes之后，将这两个文件覆盖掉旧版本相对应的两个旧版文件即可运行。 如果你已经删除新版itunes并无法重新安装，也可以直接从我的百度云中下载提取码: emn9 美中不足的是貌似图标还是禁止的样子 解决办法: 复制「访达」—「应用程序」—「iTunes.app」—「显示包内容」- 「Contents」-「Resources」中的iTunes.icns。 「访达」—「应用程序」—「iTunes.app」显示简介,拖拽iTunes.icns文件至简介顶部iTunes图标除替换即可。 参考文章macOS 10.14 mojave安装低版本iTunes 12.6.x macOS Mojave安装iTunes 12.6.x]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>iTunes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给自己git项目添加pod支持]]></title>
    <url>%2F2018%2F11%2F27%2F%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84Git%E4%BB%93%E5%BA%93%E6%B7%BB%E5%8A%A0pod%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[创建git仓库 进github，登录自己账号。如果没有自行注册。 创建个新仓库 把项目clone到本地 把自己需要添加pod支持的库添加进刚才clone的项目中 添加pod支持创建podspec文件12$ cd 刚才clone的项目路径$ pod spec create 发布的名 编辑podspec文件 设置release版本首先上传本地仓库至github 点击release，此处我以添加过，所以显示为1 验证1$ pod lib lint podspec文件名.podspec 结果多种多样根据错误提示进行修改podspec文件，如果没有错误只有警告，可以使用下面的命令进行忽略 1$ pod lib lint podspec文件名.podspec —allow-warnings 看到 xxx passed validation 说明成功 注册Cocoapods账号1$ pod trunk register 邮箱地址 '用户名' —description='描述信息' 注: 用户名和描述信息带引号,之后进入邮箱进行验证就可以了 上传代码到Cocoapods1$ pod trunk push podspec文件路径 成功后可以使用pod search进行查看如果pod search搜不到，可以进入此文件夹下~/Library/Caches/CocoaPods/删除search_index.json文件]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocal Buffers for iOS的安装及使用(使用篇)]]></title>
    <url>%2F2018%2F11%2F27%2FProtocal%20Buffers%20for%20iOS%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8(%E4%BD%BF%E7%94%A8%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[使用下载源码 1.从https://github.com/google/protobuf.git下载源码，解压，里面有支持不同语言的版本源码，我们只需要里面的支持objc的文件夹名为：objectivec 2.新建一个工程命名为ProtocolBufferTest，创建一个文件夹，假设命名为：protocolbuf， 把第一步的pb源码复制到此文件夹中： 3.使用Xcode打开工程，点击左下角+， 引用protocolBuffer源文件到工程中(源文件里面有两个工程配置文件：ProtocolBuffers_iOS.xcodeproj和ProtocolBuffers_OSX.xcodeproj，引用ProtocolBuffers_iOS.xcodeproj就好) 4.选中工程: targets—&gt;Build Phases—&gt;Link Binary With Libraries， 引用源码静态库文件：libProtocolBuffers.a 5.在工程设置搜索静态库的头文件（pb文件在protocolbuf文件夹里面）:targets—&gt;Build Setting—&gt;Search Paths—&gt;Header Search Paths, 写入：$(PROJECT)/protocolbuf 6.编写测试文件*.proto，比如新建一个文件Person.proto, 按照官方标准语法https://developers.google.com/protocol-buffers/ 编写通用代码，写好后在终端进入该Person.proto文件所在目录，使用protoc命令：protoc *.proto --objc_out=../Pro_out 进行编译。把Person.proto文件编译成Person.pbobjc.h和Person.pbobjc.m, 生成的文件在Pro_out文件夹里面。如果Person.proto源文件有语法问题，编译时会报错；当编译时什么提示都没有，表示编译成功：将编译好的*.pbobjc.h和*.pbobjc.m拖入工程中，因为不支持arc, 所以需要在*.pbobjc.m设置-fno-objc-arc, 然后就可以使用了 7.序列化与反序列化 12345678910111213141516Person *p = [[Person alloc] init];p.name = @"xiao";p.age = 2;p.address = @"哈哈哈";NSLog(@"name:%@, age:%zi, address:%@", p.name, p.age, p.address); // 序列化NSData *data = [p data];NSLog(@"data:%@", data); // 反序列化 NSError *error;Person *per = [Person parseFromData:data error:&amp;error];if (!error) &#123; NSLog(@"_____name:%@, age:%zi, address:%@_____", per.name, per.age, per.address);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ProtocalBuffers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocal Buffers for iOS的安装及使用(安装篇)]]></title>
    <url>%2F2018%2F11%2F27%2FProtocl%20Buffers%20for%20iOS%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8(%E5%AE%89%E8%A3%85%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[安装安装Protocal Buffers终端执行以下命令 1brew -v 这条命令是查看你的mac里面有没有装brew。brew是mac os里面，类似于ubuntu的apt-get的功能，都可以直接在终端输入命令然后安装程序。－v自然就是版本version的意思 下载brew安装环境 1ruby -e $(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install) 分别执行下面三条命令 123brew install automakebrew install libtoolbrew install protobuf 就是利用brew下载安装了。protobuf就是我们想要的，另外两个是依赖库 clone Protocal Buffers库执行下列命令 12git clone https://github.com/alexeyxo/protobuf-objc.git./build.sh 从github下载protobuf－objc这个工程，build脚本里面做的是编译 注意：编译工程过程中，有可能会出现错误。别慌！看编译错误的提示。一般错误只是因为环境变量和路径没有配置好，少了一些东西，例如少了编译protobuf这个工程的依赖库，按照提示添加路径即可。有了工程以后，我们就可以开始测试一下怎么用protobuf了 导入工程打开Xcode！新建一个工程！ 然后有两个方法把protobuf添加到你的工程里面，一个是直接添加，一个是利用cocoapod 强烈推荐后者，因为cocoapods能够很方便的管理第三方类库，以后人家的工程升级了，你只需要一行 pod update 就ok了。关于安装和使用cocoapod，属于另一个话题，在Podfile添加下面这个句子 platform :ios , 8.0 pod ProtocolBuffers, 在保存之后，到终端，cd到工程里面， pod install 等一会，cocoapod就会帮我们添加好，以后我们就应该打开 project的workspace，因为添加了pod作为子工程。 创建Protocal Buffers文件在你的工程里面，新建一个文件夹，假如命名叫Protobuf 在这个文件夹里面新建一个proto文件。例如要在本地储存用户信息，那么就新建一个user.proto 里面内容可以如下 123456789101112syntax = &quot;proto2&quot;; // Protocal Buffers版本message PBUser &#123;required string userId = 1; // 用户IDoptional string nick = 2; // 用户昵称optional string avatar = 3; // 用户头像optional string password = 7;optional string email = 8;optional string mobile = 9; // 手机号码optional string qqOpenId = 10; // QQ IDoptional string sinaId = 11; // SINA UserIDoptional string weixinId = 12; // WeChat UserID&#125; 上面这个例子包括了几个要素。 一个是包名。包的概念在object c里面没有，java里面有，c++里面namespace也是差不多意思。 顺便提一下，oc里面一般在库名前面添加两个字母，起的作用差不多就是包的作用，作为类的上一层组织结构。 例如官方的NS，例如AFNetworking这种第三方类库的AF。 回到正题。编写pb文件，第二个要素是message 一个message就是一个整体，里面有哪些必要的内容，哪些可选的内容。详细的proto语法随便一找一大把，就不啰嗦了。 Protocal Buffers文件转换写好了proto，接下来就是编译这个proto文件，protobuf－objc这个类库会编译声称一些源码，是读写proto数据的接口API。 编译命令如下： 先打开工程，建议单独新建一个文件夹作为输出路径，例如工程下新建文件夹Gen，用来放generate出来的.pb.h文件&amp;&amp;.pb.m文件 打开终端 cd到工程路径下 1protoc --plugin=/usr/local/bin/protoc-gen-objc person.proto --objc_out=./Gen]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ProtocalBuffers</tag>
      </tags>
  </entry>
</search>
